<!doctype html>
<html>
<header>
<title>PV16SOG BASIC</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="Author" content="Jacques Deschênes">
<meta name="Created on" content="2016-04-16">
<meta name="version" content="1.0">
<meta name="licence" content="CC-NC-SA-BY V3.0">
<link rel="stylesheet" type="text/css" href="style.css">
</header>
<body>
<a name="top"></a>	
<h2>Langage BASIC du PV16SOG</h2>
<h4>Licence</h4>
<p>  
  Ce document fait partie du projet <a href="https://github.com/picatout/pv16sog">PV16SOG</a> et est fourni sous licence <a href="https://creativecommons.org/">CC-NC-SA-BY V3.0</a><br><br>
  <b>auteur:</b> Jacques Deschênes<br>
  <b>révision</b> 1.0</br>
  <b>Copyright:</b> 2015,2016, Jacques Deschênes<br>	

</p>
<h3></a>Présentation</h3>
<p>
	L'ordinateur PV16SOG possède un interpréteur BASIC inspiré de QBASIC. Le code source BASIC est d'abord compilé en bytecode pour être exécuté sur
	une machine virtuelle à piles. Ce document décris ce langage BASIC et son utilisation. 
</p>
<p>
<ul>
<li><a href="#language">Caractéristiques du langage.</a></li>
<li><a href="#reference">référence du langage</a></li>
<li><a href="#examples">examples</a>
<ol>
<li><a href="#conway">conway.bas</a></li>
<li><a href="#spred">spred.bas</a></li>
</ol>
</li>
</ul>
</p>
<h3><a name="language"></a></a>Caractéristques du langage.</h3>
<p>
<ul>
<li>Types de données<br>
  <ul>
	  <li>Entier 16 bits signé, {-32768-32767}</li>
	  <li>Entier 8 bits (octet) non signé, {0-255}</li>
	  <li>Chaîne de caractères ASCII, {0-127}</li>
	  <li>Tableau unidimensionnel de ces 3 types de données</li>
  </ul>
</li>
<li>Programmation structurée<br>
  Contrairement au BASIC des années 70-80 <b>PV16SOG BASIC</b> est un language de programmation structuré de type procédural basé sur
  des fonctions déclarées avec le mot réservé <b>FUNC</b> ainsi que des sous-routines déclarées avec
  le mot résservé <b>SUB</b>. Il n'y a pas de numéros de lignes ni de <b>GOTO</b> ou <b>GOSUB</b> comme dans les versions plus ancienne de BASIC.
  Pour l'essentiel je me suis inspiré de <a href="https://fr.wikipedia.org/wiki/QBasic">QBASIC</a> qui venait avec MS-DOS à partir de 1991.<br>
  La compilation se fait en 1 seule passe, il n'est donc pas possible d'appeller des fonctions ou sous-routines définies plus loin dans le texte.
  Il en va de même avec les variables tableaux qui doivent-être définies avec la commande <b>DIM</b> avant d'être référencées. Par contre une variable
  scalaire globale est créée automatiquement lors de la première référence si elle n'existe pas. Cette auto-création des variables
  scalaire n'est valide qu'à l'extérieur des fonctions et sous-routines.
</li>

</li>
</ul>	
</p>
<h3><a name="reference">Référence des commandes BASIC</a></h3>
<p>
	PV16SOG BASIC est insensible à casse tous les mots réservés et indentificateurs de variables sont convertis en majuscules par le compilateur.
</p>
<h4>conventions typographiques
</h4>
<p>
	les éléments de syntaxe indiqués entre <b>'['</b> et <b>']'</b> sont des éléments optionnels. si le caractère <b>'+'</b>
	suit le caractère <b>']'</b> l'élément peut-être répété un nombre abritraire de fois.
</p>
<p>le caractère <b>'|'</b> sépare les alternatives</p>
<p>
  Dans les examples le <b>&gt;</b> au début d'une ligne représente l'invite de la ligne de commande.
</p>

<p>
	<i>expr</i>  signifit une expression arithmétique.<br>
	<i>expr_list</i> liste d'expression numérique. Les éléments sont séparés par la virgule <b>','</b>.<br>
	<i>cond</i>  signifit une condition logique résultant de la comparaison de 2 <i>expr</i>.<br>
	<i>log_expr</i> signigit un ensemble de <i>cond</i> reliées par les opérateurs logiques <b>AND</b> et <b>OR</b>.<br>
	<i>arg_list</i> est la liste des arguments passés à une sous-routine ou fonction. La virgule <b>','</b> est le séparateur de liste.<br>
	<i>val_list</i> est une liste de valeur numérique ou chaîne servant à initialiser un tableau lors de sa déclaration.<br>
	<i>var</i> représente un nom de variable.<br>
	<i>num</i> représente un nombre entier.<br>
	<i>const</i> représente une constante numérique.<br>
	<i>block</i> groupe d'instructions BASIC.<br>
</p>
<h4>Opérateurs par ordre de précédence</h4>
<p>Cette table montre les opérateurs par ordre de précédence. À précédence égale les opérateurs sont traités de gauche à droite.</p>
<table border="single">
<tr><th>opérateur</th><th>description</th></tr>
<tr><td>()</td><td>Parenthèse de groupement d'expression. Le groupement entre parenthèses est réservé aux expression arithmétiques. 
Les <i>cond</i> et les <i>log_expr</i> ne peuvent pas être regroupées.</td></tr>
<tr><td>func()</td><td>Les fonctions ont la plus haute priorité dans les expression arithmétiques.</td></tr>
<tr><td>* / %</td><td>multiplication, division entière, modulo</td></tr>
<tr><td>+ -</td><td>addition soustraction</td></tr>
<tr><td>= &gt;= &lt; &lt;= &lt;&gt; &gt;&lt; </td><td>les opérateurs de comparaison utilisés dans les <i>cond</i></td></tr>
<tr><td>NOT</td><td> négation logique appliquée au résultat d'une <i>cond</i></td> </tr>
<tr><td>AND</td><td>conjonction logique appliqué entre les <i>cond</i></td> </tr>
<tr><td>OR</td><td>alternative logique appliqué entre les <i>cond</i></td> </tr>
</table>
<h4>nom de variables</h4>
<p>
	Les noms de variables sont insensibles à la casse. Tous les noms sont convertis en majuscules par le compilateur. Un nom peut 
	avoir un maximum de 31 caractères, doit commencer par une lettre mais peut contenir des chiffres et le caractère <b>'_'</b>.
	Si le nom de la variable se termine par le caractère <b>'$'</b> il s'agit d'une variable chaîne. Si le nom se termine par le
	caractère <b>'#'</b> il s'agit d'une variable octet {0-255}. Autrement il s'agit d'une variable de type entier 16 bits dans l'interval
	de valeurs {-32768 - 32767}. Les tableaux peuvent-être de ces 3 types de données et ne peuvent avoir qu'une seule dimension.
</p>
<p>
	Les variables chaîne sont en fait des constantes, une fois une valeur assignée à une telle variable celle-ci ne peut-être changée
	sauf en utilisant un truc de programmation avancé.
</p>
<h4>valeurs litérales</h4>
<p>
Les valeurs litérales numérique peuvent-être saisie sous 3 formes:
<ol>
	<li><b>décimal</b>  23, -267 , -32560, 255</li>
	<li><b>hexadécimal</b> $23f2, $fff3</li>
	<li><b>binaire</b> #101, #100011</li>
</ol>
</p>
<p>
Les chaînes de caractères sont saisies entre guillemets <b>'"'</b>. 
Un caractère ASCII est saisie en le précédent de la barre oblique <b>'\'</b>
<div>
<pre><code> example: 
&gt;print "Hello world"
Hello world
&gt;putc \a
a
&gt;|
</code></pre><br>
</div>
</p>
<h4>fonctions et sous-routines</h4>
<p>
	Les paramètres des fonctions et sous-routines sont passées par valeur sauf si le nom de la variable est précédé du 
	caractère <b>'@'</b>. Dans ce cas le paramètre doit-être le nom d'une variable qui est passée par référence.
	<div>
    <pre><code>example:
    sprite(10,10,8,8,@lem#) ' lem# est le nom d'une variable taleau qui contient un sprite.
                            ' ce tableau doit-être passé par référence.</code></pre></div>
</p><p>                            
    La valeur de retour d'une fonction peut-être ignorée comme c'est le cas dans cet example puisque <b>sprite()</b> est
    une fonction.
</p>
<h4>commandes BASIC</h4>
<p>
	<ul>
	<li><b>ABS(expr)</b><br>
	Fonction qui retourne la valeur absolue de l'expresssion passée comme paramètre.
	<pre><code>example:
	&gt;b=-5
	&gt;? abs(3*b)
	-15
	&gt;|
	</code></pre>
	</li>
	<li><b>AND</b><br>
	conjonction logique <b>ET</b> utilisé dans les <i>log_expr</i>.
	<pre><code>example:
	if hour>=12 and hour<=17 then print "afternoon" end if
	REM si la varialbe <i>hour</i> a une valeur entre 12 et 17 imprime le mot <i>afternoon</i>.
	</code></pre>
	</li>
	<li><b>BEEP(freq,msec,wait)</b><br> sous-routine qui génère une tonalité.
	<ul>
	<li><b>freq</b> fréquence en Hertz.</li>
	<li><b>msec</b> durée en millisecondes.</li>
	<li><b>wait</b> représente une valeur booléenne {0,1} et indique si l'exécution du programme doit-être 
	suspendue pour la durée de la tonalitée. Si on passe la valeur
	<b>0</b> les instructions qui suivent s'exécutent immédiatement sans attendre la fin de la tonalité.
	</li></ul>
	<pre><code>example:
	BEEP(440,1000,1)
	REM génère une tonalitée de 440Hertz pour une durée de 1 seconde. Suspend l'exécution.</code></pre></li>
	<li><b>BOX(x0,y0,width,height,color)</b><br> sous-routine qui dessine un rectangle plein. 
	<ul><li><b>{x0,y0}</b> représente la position du coin supérieur gauche.</li>
	<li><b>width</b> représente la largeur de la boite.</li>
	<li><b>height</b> représente la hauteur de la boite.</li>
	<li><b>color</b> est la couleur de la boite (ton de gris).</li></ul>
	<pre><code>example:
	BOX(10,20,100,50,7)
	REM boite dont le coin supérieur gauche est à la position {10,20} de largeur 100 pixels,
	REM hauteur de 50 pixels avec un ton de gris de 7.</code></pre>
	</li>
	<li><b>BTEST(<i>expr</i>,bit)</b><br> fonction qui vérifie l'état d'un bit. Retourne <i>vrai</i> si le bit est à 1 sinon
	retourne <i>faux</i>.
	<ul>
	<li><b>expr</b> valeur pour laquelle on veut vérifier l'état d'un bit.</li>
	<li><b>bit</b> bit est une expression de valeur comprise entre 0 et 15 puisque les entiers sont de 16 bits. <b>0</b> est le bit 
	le plus faible et <b>15</b> le plus fort.</li>
	</ul>
	<pre><code>example:
	if btest(v1,0) then print "nombre impair" end if
	REM si le bit zéro est à 1 il s'agit d'un nombre impair.
	if btest(v2,15) then print "nombre negatif" end if
	REM si le bit 15 est à 1 il s'agit d'un nombre négatif.</code></pre>
	</li>
	<li><b>BYE</b><br> Cette commande termine l'éxécution d'un programme et peut-être utilisée n'importe où à l'intérieur
	d'un programme.
	<pre><code>example:
	if key()='q' then BYE end if
	REM termine l'exécution si la touche 'Q' est enfoncée.
	</code></pre></li>
	<li><b>CASE</b><br> Voir <a href="#selectcase">SELECT CASE</a></li>
	<li><b>CLS [color]</b><br> Efface l'écran. Si le paramètre <i>color</i> est présent assigne cette valeur
	comme nouvelle couleur de fond avant d'effacer l'écran.
	<pre><code>example:
	CLS 7
	REM la nouvelle couleur de fond sera <b>7</b> et tous les pixels auront cette couleur après cette commande.</code></pre></li>
	<li><b>COLOR(police,fond)</b><br> Fixe la couleur de la police de caractère et du fond d'écran.
	<ul>
	<li><b>police</b> expression arithmétique dont la valeur doit-être entre 0 et 15. Détermine la couleur des caractères.</li>
	<li><b>fond</b> expression arithmétqiue dont la valeur doit-être entre 0 et 15. Détermine la couleur de fond d'écran.
	<pre><code>example:
	COLOR(15,0)
	REM caractère blanc sur fond noir.</code></pre></li></ul>
	</li>
	<li><b>CONST nom=valeur [,nom=valeur]</b><br> Déclare une ou plusieurs constantes séparées par une virgule <b>','</b>.
	<ul><li><b>nom</b> est le nom de la constante. Les constantes sont de types entier 16 bits ou chaîne ASCII.</li>
	<li><b>valeur</b> selon le type de la constante il s'agit d'un entier ou d'une chaîne ASCII.</li></ul>
	<pre><code>example:
	CONST age=30, salaire=32000, nom$="Capitaine Bonhomme"
	REM défini 3 constantes dans la même déclaration.</code></pre>
	</li>
	<li><b>CURCOL()</b><br> Retourne la poisition colonne du curseur texte.
	<pre><code>example:
	if curcol()=38 then locate(curline()+1,0) end if
	</code></pre></li>
	<li><b>CURLINE()</b><br> Retourne la position ligne du curseur texte.
	<pre><code>example:
	if curline()=20 and curcol()=39 then scrlup(8): locate(curline(),0) end if</code></pre></li>
	<li><b>DIM <i>var</i>[=<i>value</i>] [,<i>var</i>[=<i>value</i>]]</b><br>
	 <b>DIM <i>var</i>(<i>number|constant</i>)[=(value_list)] [,<i>var</i>(<i>number|constant</i>)[=(value_list)]]</b><br>
	 Cette commande sert à déclarer des variables. Les variables peuvent-être initialisées lors de leur déclaration.
	 Les variables tableaux doivent-être initialisées avec le nombre exact d'éléments déclarés dans la dimension  du tableau.
	 Les valeurs d'initialisation sont soit des entiers, des chaînes ou des constantes pré-définies.
	 <pre><code>example:
	 DIM v1=34, v2#=234 ' la variable entier 16 bits v1 prend la valeur 34
	                    ' la variable octet v2 prend la valeur 234
	 DIM t1(4)=(1,2,3,4) ' le tableau t1 contient 4 éléments qui sont initialisées.
	 DIM msg$(3)=("nom","prenom","age") ' tableau de 3 chaînes initialisé.
	 </code></pre></li>
	 <li><a name="do"></a><b>DO</b><br>
	  <i>block</i><br>
	  <b>LOOP WHILE <i>log_expr</i></b><br>
	  Le bloc d'instruction est exécuté en boucle tant que <i>log_expr</i> est vrai.<br>
	  <b>DO</b><br>
	  <i>block</i><br>
	  <b>LOOP UNTIL <i>log_expr</i></b></b><br> 
	  Le bloc d'instruction est exécuté en boucle jusqu'à ce que <i>log_expr</i> soit vrai.
	<pre><code>example:
	&gt;i=0 : DO ? i : i=i+1 LOOP UNTIL i=5
	0
	1
	2
	3
	4
	&gt;i=9 : DO ? i : i=i-1 : LOOP WHILE i
	9
	8
	7
	6
	5
	4
	3
	2
	1
	</code></pre></li>
	<li><b>ELSE</b><br>
	Est utilisé avec le <a href="#if">IF</a> et le <a href="#selectcase">SELECT CASE</a>.</li>
	<li><b>END FUNC</b><br>
	Voir <a href="#function">FUNC</a>.<br>
	<b> END SUB</b><br>
	Voir <a href="#sub">SUB</a>.<br>
	<b>END IF</b><br>
	Voir <a href="#if">IF</a><br>
	<b>END SELECT</b><br>
	Voir <a href="#selectcase">SELECT CASE</a>.
	</li>
	<li><b>EXIT SUB</b><br> Voir <a href="#sub">SUB</a>.</li>
	<li><a name="for"></a><b>FOR <i>var=expr</i> TO <i>expr</i> [STEP <i>expr</i>]</b><br>
	  <i>block</i><br>
	<b>NEXT <i>var</i></b><br>
	Permet l'exécution d'un bloc d'instructions en boucle un nombre de fois déterminé par l'incrémentation d'une variable. Le programme sort de
	la boucle lorsque la variable dépasse la valeur de la limite. l'incrément par défaut est <b>1</b>. Si <b>STEP</b> est présent l'incrément est
	le résultat d'<i>expression</i> et peut-être un entier quelconque. La valeur de la variable de contrôle est vérifiée au début de la boucle
	d'instructions. Si au départ elle dépasse la limite le bloc d'instruction n'est jamais exécuté.<br>
	<pre><code>example:
	FOR i=0 TO 10 STEP 2
	  print i
	next i
	REM  affiche les nombres pairs de 0 à 10</code></pre>
	</li>
	<li><b><a name="function"></a>FUNC name(<i>arg_list</i>)</b><br>
	[<b>LOCAL var_list</b>]<br>
	<i>block</i><br>
	<b>RETURN <i>expr</i></b><br>
	<b>END FUNC</b><br>
	Sert à définir une fonction.<br>
	<ul>
		<li><b>name</b> est le nom de la fonction qui sera utilisé pour son appel.</li>
		<li><i>arg_list</i> Liste du nom des arguments de la fonctions. Les éléments sont séparé par la virgule <b>','</b></li>
		<li><b>LOCAL var_list</b> Si la fonction utilise des variables locales la liste doit-être donnée au début.</li>
		<li><i>block</i> bloc d'instructions exécuté par cette fonction.</li>
		<li><b>RETURN <i>expr</i></b> Cette directive termine la fonction en retournant la valeur de l'expresssion qui suit. Cette 
		directive peut apparaître plusieurs fois dans le bloc d'instruction dans une structure conditionnelle.
		<pre><code>example:
		REM cette fonction calcule  la factorielle d'un entier
		REM méthode récursive
		FUNC fact(n)
		  if n<1 then 1/0 end if ' nombre &lt; 1 génère une exception
		  if n=1 then return 1 end if
		  return n*fact(n-1)
		END FUNC
		
		REM même fonction mais en utilisant une boucle FOR
		FUNC fact(n)
		LOCAL f,i
		   f=1
		   for i=2 to n 
		     f=f*i
		   next i
		   return f
		END FUNC
		</code></pre></li>
	</ul>
	</li>
	<li><b>GETPIXEL(x,y)</b><br>
	Retourne la couleur du pixel à la position {x,y}.
	<pre><code>example:
	? GETPIXEL(10,20) ' affiche la couleur du pixel à la coordonnée {10,20]</code></pre>
	</li>
	<li><a name="if"></a><b>IF <i>log_expr</i> THEN</b><br>
	<i>block</i><br>
	<b>ELSE</b><br>
	<i>block</i><br>
	<b>END IF</b><br>
	L'expression logique qui suit le <b>IF</b> est évaluée et si la valeur est vrai le bloc d'instruction qui
	suit le <b>THEN</b> est exécuté. Dans le cas contraire c'est le bloc d'instruction qui suit le <b>ELSE</b>
	qui est exécuté.
	<pre><code>example:
	IF btest(4,0) then
	  ? "nombre impair"
	ELSE
	  ? "nombre pair"
	END IF
	REM va imprimé <i>nombre pair</i>
	</code></pre>
	</li>
	<li><b>INPUT [<i>chaîne</i>,] <i>var_list</i></b>
	<ul>
		<li><i>chaîne</i> est un message facultatif à imprimer à l'écran avant la saisie des données.</li>
		<li><i>var_list</i> est la liste des variables auquelles les valeur saisies au clavier seront affectées.
		La saisie se fait une variable à la fois dans leur ordre d'apparation dans la liste. Pour chaque variable
		son nom est affichée à l'écran suivit d'un point d'interrogation.</li>
	</ul>
	<pre><code>example:
	INPUT "Entrez votre prenom et votre age", nom$, age
	'ceci apparaît à l'écran:
	 Entrez votre prenom et votre age
	 prenom? <i>Arthur</i>
	 age? <i>40</i>
	 
	 &gt;? nom$, age
	 Arthur 40
	</code></pre>
	</li>
	<li><b>JSTICK()</b><br>
	Lecture du joystick. Retourne zéro si aucun contact n'est fermé. Autrement retourne une valeur
	qui correspond à la combinaison des constacts fermés. 
	<table border="single">
	<tr><th>contact</th><th>valeur</th></tr>
	<tr><td>bouton</td><td>1</td></tr>
	<tr><td>levier vers la droite</td><td>2</td></tr>
	<tr><td>levier vers la gauche</td><td>4</td></tr>
	<tr><td>levier vers le bas</td><td>8</td></tr>
	<tr><td>levier vers le haut</td><td>16</td></tr>
	</table>
	Deux contacts peuvent-être fermés en même temps. Par exemple si le levier est poussé vers le haut et la droite la valeur
	retourné est 18.
	<pre><code>example:
	select case jstick()
	case 1
	  bye
	case 2
	  ? "droite"
	case 4
	  ? "gauche"
	case 8
	  ? "bas"
	case 16
	  ? "haut"
	case 18
	  ? "haut et droite"
	case else
	  ? "etc"
	end select  
	</code></pre>
	</li>
	<li><b>KEY()</b><br>
	Cette fonction retourne la touche tapée au clavier ou <b>0</b> si aucune touche n'est tapée.
	<pre><code>example:
	CASE SELECT key()
	case \q 'quitte le programme
	  bye
	case \e ' efface l'écran
	  cls
	case \h ' salutation
	  print "hello\n" ' \n à l'intérieur d'une chaîne pour imposer un retour à la ligne.
	end SELECT
	REM j'ai mélanger intentionnellement les mots réservés entre majuscules et minuscules
	REM pour montrer que la casse n'a pas d'importance.
	</code></pre></li>
	<li><b>LEN(<i>var$</i>)</b><br>
	<b>LEN ("chaîne")</b><br> 
	Cette fonction retourne la longueur de la chaîne ASCII.
	<pre><code>example:
	&gt;nom$="Arthur Roy"
	&gt;? len(nom$)
	10
	&gt;? len("hello world")
	11
	&gt;|</code></pre>
	</li>
    <li><b>[LET] <i>var_name[#]</i>i>[(<i>epxr</i>)]=<i>expr</i></b><br>
    <b>[LET] <i>var_name$</i>[(<i>expr</i>)]=<i>chaîne</i></b><br>
    Assigne une valeur à une variable. Le mot réservé <b>LET</b> est entre crochets car il est optionnel.
    <pre><code>example:
    LET a=34*5
    a=34*5  REM c'est la même chose
    REM ça peut aussi être une variable tableau
    DIM tab(4)
    tab(1)=-1234  ' le premier élément du tableau vaut maintenenat <b>-1234</b>
    </code></pre>
    </li>
    <li><b>LINE(x0,y0,x1,y1,color)</b><br>
    Dessine une ligne à l'écran.
    <ul>
    <li><b>{x0,y0}</b> coordonnées première extrémité de la ligne.</li>
    <li><b>{x1,y1}</b> coordonnées de l'autre extrémité de la ligne.</li>
    <li><b>color</b> couleur (ton de gris) de la ligne.</li>
    </ul>
    <pre><code>example:
    line(0,0,100,100,15)</code></pre>
    </li>
	<li><b>LOCAL <i>var_list</i></b><br>
	Déclaration de la liste des variables utilisées dans une 
	<a href="#function">fonction</a> ou une <a href="#sub">sous-routine.</a></li>
	<li><b>LOCATE(ligne,colonne)</b><br>
	Positionne le curseur texte à l'endroit désigné.
	<ul>
		<li><i>ligne</i> numéro de la ligne, {0-20}</li>
		<li><i>colonne</i> numéro de la colonne, {0-39}</li>
	</ul>
	<pre><code>example:
	LOCATE(10,0) ' le curseur texte est maintenant au début de la 11ième ligne.
	</code></pre>
	</li>
	<li><b>LOOP</b><br>
	voir <a href="#do">DO</a></li>
	<li><b>MAX(<i>expr1</i>,<i>expr2</i>)</b><br>
	Cette fonction retourne le plus grand des 2 entiers.
	<pre><code>example:
	&gt;? max(56,30)
	56
	&gt;|</code></pre></li>
	<li><b>MDIV(<i>expr1</i>,<i>expr2</i>,<i>expr3</i>)</b><br>
	Cette fonction retourne <i>expr1*expr2/expr3</i>. Le résultat de la 
	multiplication est conservé sur 32 bits pour obtenir une valeur juste pour la division.
	<pre><code>
	&gt; ? 32540*8/33
	-54 <i>'mauvaise réponse à cause du débordement de la multiplication.</i>	
	&gt;? mdiv(3540,8,33)
	7888 <i>'bonne réponse car le résultat de la multiplication est conservé sur 32 bits.</i>
	&gt;REM multiplication d'un nombre par une approximation rationnelle de PI
	&gt;? mdiv(5400,355,113)
	16964 <i>'erreur &lt; 0,5 </i>
	</code></pre></li>
	<li><b>MIN(<i>expr1</i>,<i>expr2</i>)</b><br>
	Cette fonction retourne le plus petit des 2 entiers.
	<pre><code>example:
	&gt;? min(34,-5)
	-5
	&gt;|</code></pre></li>
	<li><b>NEXT <i>var_name</i></b><br>
	Voir <a href="#for">FOR</a></li>
	<li><b>NOISE(<i>expr</i>)</b><br>
	Produit un bruit blanc pour une durée <i>expr</i> exprimée en millisecondes.
	<pre><code>example:
	&gt;noise(100) 'produit le bruit d'une chute d'eau durant 0,1 seconde.
	</code></pre></li>
	<li><b>NOT <i>log_expr</i></b><br>
	Négation de la valeur d'une expression logique.
	<pre><code>example:
	if not 3&gt;4 then ? "3 n'est pas plus grand que 4" end if
	3 n'est pas plus grand que 4
	</code></pre></li>
    <li><b><i>log_expr1</i> OR <i>log_expr2</i></b><br>
    retourne vrai si l'une ou l'autre des 2 <i>log_expr</i> est vrai.
    <pre><code>example:
    while 1
    if key() or jstick()=1 then bye end if
    wend
    REM sort de la boucle si une touche ou le bouton du joystik
    REM est enfoncé.
    </code></pre></li>
    <li><b>PAUSE(<i>expr</i>)</b><br>
    Suspend l'exécution du programme pour une durée en millisecondes égale à la valeur de <i>expr</i>.
    <pre><code>example:
    &gt;pause(1000)  REM l'invite de commande var réapparaître après 1 seconde.
    </code></pre></li>
    <li><b>PRINT|? [<i>expr</i>|<i>chaîne</i>|<i>var</i>] [,<i>expr</i>|<i>chaîne</i>|<i>var</i>]+ [;]</b><br>
    Imprime à l'écran la liste des expressions, chaîne ou variable. Un espace sépare chaque valeur. Si la commande est terminée
    par une <b>';'</b> il n'y a pas de retour à la ligne.
    <pre><code>example:
    &gt;DIM a=34, msg$="hello world"
    &gt;print a, msg$, "bonjour" 
    34 hello world bonjour
    
    &gt;|
    </code></pre></li>
    <li><b>PUTC expr</b><br>
    Imprime un caractère à l'écran sans ajout d'espace ou de retour à la ligne. Si <i>expr</i> est évaluée en dehors
    de l'intervalle {0-127} rien n'est imprimé. La majorité des codes entre 0 et 31 n'ont aucun effet. les codes reconnus sont les suivants:
    <ul>
		<li><b>7</b> alerte sonore</li>
		<li><b>9</b> tabulation</li>
		<li><b>10</b> retour à la ligne</li>
		<li><b>12</b> efface écran</li>
		<li><b>13</b> retour à la ligne</li>
    </ul>
    <pre><code>example:
    &gt;putc \a : putc 98
    ab
    &gt;
    </code></pre></li>
    <li><b>RECT(x,y,width,height,color)</b><br>
    Dessine un rectangle vide à l'écran.
    <ul>
    <li><b>{x,y}</b> coordonnée du coin supérieur gauche</li>
    <li><b>width</b> largeur du  rectangle en pixels.</li>
    <li><b>height</b> auteur du rectangle en pixels.</li>
    <li><b>color</b> couleur (ton de gris) du périmèter du rectangle.</li>
    </ul>
    <pre><code>RECT(10,10,20,60,7) ' position {10,10}, largeur 20, hauteur 60,  couleur 7</code></pre></li>
	<li><b>REM|' <i>texte</i></b><br>
	Indique un commentaire. Les commentaires se termine à la fin de la ligne.
	<pre><code>example:
	REM ce commentaire se termine a la fin de ligne.
	' l'apostrophe peut remplacé le mot REM.</code></pre></li>
	<li><b>RETURN</b><br>
	Voir <a href="#function">FUNC</a></li>
	<li><b>RND()</b><br>
	Cette fonction retourne un entier de 16 bits pseudo aléatoire.
	<pre><code>example:
	&gt;while not key() : ? rnd() : wend
	REM imprime sans arrêt une série de nombre aléatoire.
	REM il faut enfoncer une touche du clavier pour arrêter l'exécution.</code></pre></li>
	<li><b>SCRLUP(expr)</b><br>
	Fait glisser l'affichage vers le haut d'un nombre de pixels correspondant à la valeur
	de <i>expr</i>
	<pre><code>example:
	&gt; scrlup(8) ' défilement vers le haut de la hauteur d'un caractère.</code></pre></li>
	<li><b>SCRLDN(expr)</b><br>
	Fait glisser l'affichage vers le bas d'un nombre de pixels correspondant à la valeur
	de <i>expr</i>
	<pre><code>example:
	&gt; scrldn(8) ' défilement vers le bas de la hauteur d'un caractère.</code></pre></li>
	<li><b>SCRLRT(expr)</b><br>
	Fait glisser l'affichage vers la droite d'un nombre de pixels correspondant à la valeur
	de <i>expr</i>. Cette valeur doit-être un nombre pair, sinon le nombre pair inférieur est choisi.
	<pre><code>example:
	&gt; scrlrt(6) ' défilement vers la droite de la largeur d'un caractère.</code></pre></li>
	<li><b>SCRLLT(expr)</b><br>
	Fait glisser l'affichage vers la gauche d'un nombre de pixels correspondant à la valeur
	de <i>expr</i>. Cette valeur doit-être un nombre pair, sinon le nombre pair inférieur est choisi.
	<pre><code>example:
	&gt; scrllt(6) ' défilement vers la gauche de la largeur d'un caractère.</code></pre></li>
	<li><a name="selectcase"></a><b>SELECT CASE expr</b><br>
	<b>CASE </b><i>expr_list</i><br>
	<i>block</i><br>
	[<B>case </B><i>expr_list</i><br>
	<i>block</i>]+<br>
	[<b>CASE ELSE</b><br>
	<i>block</i>]<br>
	<b>END SELECT</b><br> 
	Cette structure de contrôle permet de sélectionnr un bloc d'instruction en fonction de la valeur d'une expression. Contrairement au
	<i>switch</i> du langage 'C' l'exécution d'un bloc se termine au prochain <b>CASE</b> sans besoin de mettre un <i>break</i>.
	<pre><code>example:
	select case jstick()
	case 1 ' bouton du joystick enfoncé
	   bye
	case 2 ' levier à droite
	  move_right()
	case 4 ' levier vers la gauche
	  move_left()
	case 8 ' levier vers le bas
	  move_down()
	case 16 ' levier vers le haut
	  move_up()
	end select
	REM contrôle du mouvement d'un sprite à l'écran à l'aide du joystick     
	  </code></pre></li>
	<li><b>SETPIXEL(x,y,color)</b><br>
	Colore le pixel à la coordonnée <i>{x,y}</i> avec la couleur <i>color</i>.
	<pre><code>example:
	setpixel(10,20,4) ' le pixel à la postion {10,20} prend la valeur 4
	</code></pre></li>  
	<li><b>SETTMR(<i>expr</i>)</b><br>
	Initialise la minuterie de pause sans bloquer l'exécution. À utiliser avec la fonction
	<a href="#timeout">TIMEOUT</a>
	<pre><code>example:
    DIM count
    settmr(100) ' minuterie initialisée à 100 millisecondes.
    while not timeout()
      rem combien de WHILE par seconde?
      count=count+1
    wend
    print "boucle WHILE par seconde: ",10*count
	  </code></pre></li>
	<li><b>SHL(<i>expr</i>)</b><br>
	Décale vers la gauche <i>expr</i> de 1 bit (multiplication par 2).
	<pre><code>example:
	&gt;? shl(4)
	8
	&gt;|</code></pre></li>
	<li><b>SHR(<i>expr</i></b><br>
	Décale vers la droite <i>expr</i> de 1 bit (division par 2).
	<pre><code>example:
	&gt;? shr(-9)
	-5 
	&gt; REM pensiez-vous que ça donnait -4 ?
	&gt;|</code></pre></li> 
	<li><b>SPRITE(x,y,width,height,@var#)</b><br>
	fonction qui affiche un sprite à l'écran. Cette fonction retourne une
	valeur booléenne qui indique si le sprite est entré en collision avec un autre objet.
	<ul>
		<li><b>{x,y}</b> Coordonnées du coin supérieur gauche du sprite.</li>
		<li><b>width</b> Largeur du sprite en pixels.</li>
		<li><b>height</b> Hauteur du sprite en pixels.</li>
		<li><b>var#</b> Nom de la variable tableau d'octets qui contient le sprite. Cette variable doit-être passée par 
		référence comme indiqué par le caractère <b>'@'</b>.</li>
	</ul>
	<pre><code>example:
	dim cross#(8)=($0f,$f0,$ff,$ff,$ff,$ff,$0f,$f0) 'petite croix de 4x4 pixels
	if sprite(56,24,4,4,@cross#) then ? "collision" end if
	</code></pre>
	Les sprites sont affichés à l'écran en utilisant une fonction XOR (OU exclusif) pixel à pixel. Cette méthode 2 avantages.
	Le premier est qu'elle permet de détecter les collisions en supposant que le fond d'écran est noir (0). Le deuxième est qu'il
	suffit de réafficher le sprite par dessus lui-même pour l'effacer. la méthode pour déplacer un sprite à l'écran est la suivante:
	<pre><code>
	while 1
	  collision=sprite(x,y,8,8,@spr#) ' affiche un sprite de 8x8 pixels
	  pause(10) ' pause de 10 millisecondes, cette valeur n'est pas critique peut-être 20 msec.
	  sprite(x,y,8,8,@spr#) 'efface le sprite
	  ' ici on peut mettre du code pour gérer les collisions
	  '...
	  select case jstick() 'lecture du joystick et déplacement dans la direction indiquée.
	  case 1 ' bouton enfoncé
	    cls
	    bye
	  case 16 'vers le haut
	    if y&gt;0 then y=y-1 end if
	  case 8 'vers le bas
	    if y&lt;170-8 then y=y+1 end if
	  case 2 'vers la droite
	    if x&lt;240-8 then x=x+1 end if
	  case 4 ' vers la gauche
	    if x&gt;0 then x=x-1 end if
	  ' on peut ajouter des CASE pour gérer les 4 directions diagonales.
	  '...  
	  end select  
	wend   
	</code></pre>
	</li> 
	<li><b>SRCLEAR(<i>expr</i>)</b><br>
	Cette commande efface le contenu de la mémoire SPI RAM. <i>expr</i> est le nombre d'octets à effacer. L'effacement se fait 
	toujours à partir de l'adresse 0.
	<pre><code>example:
	srclear(1000) ' efface les 1000 premiers octets de la mémoire SPI RAM.</code></pre></li>
	<li><b>SRLOAD <i>"file_name"</i></b><br>
	<b>SRLOAD <i>var$</i></b><br>
	Il s'agit d'une fonction qui charge en mémoire SPI RAM le contenu d'un fichier. Le chargement débute à l'adresse 0.
	La taille maximale est de 65535 octets. La fonction retourne le nombre d'octets chargés.
	<pre><code>example:
	size=srload "test.spr" ' charge le fichier <i>test.spr</i> et retourne sa grandeur dans <i>size</i>.</code></pre></li>
	<li><b>SRREAD(<i>adr</i>,@var,<i>size</i>)</b><br>
	Lecture d'un bloc d'octets de la SPI RAM dans une variable.
	<ul><li><b>adr</b> adresse SPI ou doit débuter la lecture.</li>
	<li><b>var</b> nom de la variable dans laquelle les valeurs lues seront copiées. Cette variable doit-être passée par
	référence comme l'indique le caractère <b>'@'</b>.
	<li><b>size</b> nombre d'octets à lire.</li>
	<pre><code>example:
	DIM i, spr#(32)
	srread(0,@i,2) ' lit un entier et le met dans la variable <i>i</i>.
	srread(4,@spr#,32) ' lit un bloc de <i>32</i> octets à partir de l'adresse <i>4</i> dans le tableau <i>spr#</i>
	</code></pre>
	</li>
	</ul>
	<li><b>SRSAVE <i>"file_name"</i>, <i>size</i></b><br>
	<b>SRSAVE <i>var$</i>, <i>size</i></b><br>
	Sauvegarde dans un fichier le contenu de la mémoire SPI RAM. La sauvegarde se fait à partir de l'adresse 0.<br>
	<ul>
	<li><b>file_name|var$</b> Nom du fichier de sauvegarde.</li>
	<li><b>size</b> Nombre d'octets à sauvegarder.</li></ul>
	<pre><code>example:
	srsave "test.dat", 1024 ' sauvegarde <i>1024 octets</i> dans le fichier <i>test.dat</i></code></pre>
	</li>
	<li><b>SRWRITE(<i>adr,@var,size</i>)</b><br>
	Copie le contenu d'une variable dans la mémoire SPI RAM.<br>
	<ul>
	<li><b>adr</b> adresse destination dans la SPI RAM.</li>
	<li><b>var</b> nom de la variable qui contient les données à transférer dans la SPI RAM. Cette variable est passée par référence
	comme indiqué par le caractère <b>'@'</b>.</li>
	<li><b>size</b> nombre d'octets à copier.</li>
	</ul>
	<pre><code>example:
	DIM i, spr#(32)
	srwrite(0,@i,2) ' écrit  l'entier <i>i</i> dans la SPI RAM à l'adresse 0.
	srwrite(4,@spr#,32) ' écris un bloc de <i>32</i> octets à l'adresse <i>4</i> à partir du tableau <i>spr#</i>
	</code></pre>
	</li>
	<li><a name="sub"></a><b>SUB name([<i>arg_list</i>])</b><br>
	[<b>LOCAL</b> <i>var_list</i>]<br>
	<i>block</i><br>
	[if <i>log_expr<i> then </i></i><b>EXIT SUB</b> end if<br>
	<i>block</i>]<br>
	<b>END SUB</b><br>
	Cette déclaration sert à définir une sous-routine. La liste des variables locales, s'il y en a, doit-être énumérée au début.
	<b>EXIT SUB</b> peut-être utilisé pour sortir de la sous-routine si une certaine condition est remplie.
	<pre><code>example:
	sub box_madness() ' dessine des boites au hasard
	  local x,y,w,h,c
	  while not key() ' arrête lorsqu'une touche est enfoncée.
	    x=abs(rnd())%240
	    y=abs(rnd())%170
	    w=abs(rnd())%240
	    h=abs(rnd())%170
	    c=abs(rnd())%16
	    box(x,y,w,h,c)
	  wend
	end sub
	</code></pre>
	</li>
	<li><b>THEN</b><br>
	Voir <a href="#if">IF</a></li>
	<li><b>TICKS()</b><br>
	 PV16SOG possède un compteur interne qui est incrémenté à chaque milliseconde. Cette fonction retourne la valeur de ce compteur.
	 Ce compteur de 16 bits retourne à zéro à intervalle d'environ 65 secondes.
	 <pre><code>example:
	 REM utilisation du compteur interne pour mesurer un interval de temps.
	 t0=ticks()
	 for i=0 to 10000
	 next i
	 ? "temps écoulé pour 10000 itération FOR ", ticks()-t0
	 </code></pre>
	 </li>
	 <li><b>TIMEOUT()</b><br>
	 Cett fonction vérifie la valeur de la minuterie de pause et retourne vrai si elle est expirée.
	 <pre><code>example:
	 settmr(1000)
	 while not timeout()
	   ? "pas encore expiree"
	 wend
	 </code></pre>
	 </li>
	 <li><b>TONE(<i>note,msec,wait</i>)</b><br>
	 Fait entendre une note de la gamme tempérée.
	 <ul>
		 <li><b>note</b> note de la gamme dans l'intervalle {0-47}. <b>0</b> correspond à DO2# et <b>47</b> à DO6. L'étendu est de 4 octaves. On peut
		 utiliser un nombre négatif pour faire une pause.</li>
		 <li><b>msec</b> durée de la note en millisecondes.</li>
		 <li><b>wait</b> Si cette valeur vaut <b>0</b> l'exécution du programme se poursuit pendant l'exécution de cette note. Autrement le programme
		 attend la fin de la note avant de poursuivre.</li>
	 </ul>
	 <pre><code>example:
	 REM ce programme joue les 5 premières notes
	 REM du thème musical du film rencontre du 3ième type.
	 dim ce3k#(10)=(13,200,15,200,11,200,1,200,6,200)
	 for i=1 to ubound(ce3k#) step 2
	     tone(ce3k#(i)+12,3*ce3k#(i+1),1)
	 next i
	 </code></pre>
	 </li>
	 <li><b>TRACE(0|1)</b><br>
	 C'est un outil de débogage des programmes BASIC pour les utilisateurs avancés. 
	 Pour l'utiliser il faut connaître le fonctionnement de la machine virtuelle et ses
	 <a href="./stackvm.html#opcoddes">opcodes</a>.<br>
	 la commande <b>trace(1)</b> active le mode trace et <b>trace(0)</b> le désactive. Le mode trace exécute le programme pas à pas et affiche
	 après chaque instruction de la machine virtuelle le contenu de la pile des arguments ainsi que le nombre
	 d'éléments sur la pile des retours. La touche <b>ESC</b> permet de quitter le mode trace, toute autre touche exécute le code machine
	 suivant et revient à pause.  La mode peut-être activé/désactivé n'importe où dans le programme. L'état de l'écran est sauvegarder dans 
	 la RAM SPI avant que les informations de traçage soit affichée et l'écran est restauré avant de continuer l'exécution. Pour plus 
	 d'information consultez le document <a href="./stackvm.html">stackvm.html</a>
	 <pre><code>example:
	 REM activation conditionnelle de trace
	 for i=1 to 100
	   if (i=50) then trace(1) end if
	   ? i
	 next i
	 
	 
	 REM information qui vont apparaître 
	 REM à l'écran de traçage lors de l'activation
     
     28
     R:2
     1 : 31726	 
     
     ' 28 est le dernier opcode exécuté et correspond à l'intruction <b>LIT</b>
     ' R:2 signifit qu'il y a 2 éléments sur la pile <b>rstack</b>
     ' 1 : 31726  signifit qu'il y a 1 élément sur la pile des arguments
     '           31726 est la valeur de cet argument. Il s'agit d'un pointeur
     '           sur la variable <i>i</i> qui va être imprimé par l'instrution
     '           suivante.
	 </code></pre></li>
	 <li><b>UBOUND(<i>var</i>)</b><br>
	 Cette fonction retourne la valeur du dernier indice d'une variable tableau.
	 <pre><code>example:
	 &gt;dim vector(100)
	 &gt;? ubound(vector)
	 100
	 &gt;|
	 </code>
	 </pre></li>
	 <li><b>USE "<i>file</i>"</b><br>
	 Cette directive sert à compiler un fichier BASIC utilisé par le fichier principal. <i>file</i> est le nom du fichier à inclure. 
	 Il doit s'agir d'un fichier existant sur la carte SD. Un fichier inclus peut aussi utiliser la directive <b>USE</b> 
	 jusqu'à un niveau d'imbrication de 4. 4 étant le nombre maximal de fichiers pouvant-être ouvert simultanément.
	 <pre><code>example:
	 use "joystick.inc" ' fichier définissant des constantes pour le joystick
	 use "lem.spr"      ' fichier définissant un sprite appellé LEM.
	 ' code du programme principal
	 .
	 .
	 .
	 </code></pre>
	 </li>
	 <li><b>video(<i>expr</i>)</b><br>
	 Si <i>expr</i> est évaluée à <b>0</b> la sortie vidéo est désactivée autre elle est activée.  La sortie vidéo accapare le plus grand
	 nombre de cycles du CPU. La désactivation de la sortie vidéo permet d'accélérer une sous-routine.
	 <pre><code>example:
	 sub test(n)
	 local t0
	   cls
	   if n then 'rapide
	     t0=ticks()
	     video(0)
	     box(0,0,240,170,4)
	     video(1)
	     ? ticks()-t0, "msec"
	   else 'lent
	     t0=ticks()
	     box(0,0,240,170,4)
	     ? ticks()-t0, "msec"
	   end if
	 end sub
	 
	 &gt; test(0)
	 55 msec
	 &gt; test(1)
	 32 msec
	 </code></pre></li>
	 <li><b>WAITKEY()</b><br>
	 Cette fonction attend que l'utilisateur enfonce une touche au clavier et retourne la valeur de cette touche.
	 <pre><code>example:
	 &gt;putc waitkey()
	 r
	 &gt;|
	 REM l'utilisateur a enfoncé la touche 'r'</code></pre></li>
	 <li><b>WHILE <i>log_expr</i></b><br>
	 [<i>block</i>]<br>
	 <b>WEND</b><br>
	 La structure de contrôle <b>WHILE</b> exécute le bloc d'instructions <i>block</i> terminé par le <b>WEND</b> tant que <i>log_expr</i>
	 retourne vrai.<br>
	 <pre><code>example:
	 dim i=0
	 while i<100
	   ? i
	   i=i+1
	 wend
	 0
	 1
	 2
	 ...
	 99
	 </code></pre>
	 </li>
	</ul>
</p>
<h3><a name="examples">Examples de programmes</a></h3>
<h4><a name="conway"></a>Le jeux de la vie</h4>
<p>
	Ce premier example est une implémentation du <a href="https://fr.wikipedia.org/wiki/Jeu_de_la_vie">jeux de la vie</a> 
	du mathématicien <a href="https://fr.wikipedia.org/wiki/John_Horton_Conway">John H. Conway</a>. En dépit de son nom 
	il ne s'agit pas d'un jeux mais d'une simulation d'automate cellulaire 	à 2 dimensions. 
	Au démarrage un curseur	en forme de croix apparaît au centre de l'écran. Il s'agit de créer une configuraton de départ.
	On déplace le curseur à l'aide des flèches du clavier. La touche <b>C</b>
	ajoute une cellule à la position du curseur et la touche <b>ESPACE</b> supprime une cellule existante. Pour démarrer 
	la simulation on utilise la touche <b>ENTER</b>. On regarde évoluer
	cet univers d'automates cellulaires d'une génération à l'autre. Le nombre de générations est affiché dans le coin inférieur gauche.
	Même si ce BASIC ne permet que la définition de tableaux à 1 seule dimension ce programme simule un tableau d'octets à 3 dimensions 
	<b>g#(1368)</b> qui est la grille univers dans lequel évoluent les automates cellulaires.
</p><p>
	Vous pouvez vous représenter
	cette grille comme une feuille de papier quadrillé dont certains carrés seraient noircis. Ces carrés noircis représenteraient
	les cellules vivantes. Pour chaque carré de la feuille on compte le nombre de cellules vivantes qui l'entoure et on applique 
	les règles suivantes:
	<ol>
	<li>S'il y a moins de 2 cellules vivantes dans le voisinage ce carré sera vide à la prochaine génération. Si le carré est vivant il meurt.</li>
	<li>S'il y a 2 cellules vivantes dans le voisinage ce carré demeurera dans le même état à la prochaine génération. C'est à dire
	vide s'il est vide ou plein s'il est plein.</li>
	<li>S'il y a 3 cellules vivantes dans le voisinage et que le carré est vide il sera plein à la prochaine génération. C'est une naissance.</li>
	<li>S'il y a plus 3 cellules vivantes dans le voisinage et que le carré est plein il sera vide à la prochaine génération. Mort par surpopulation.</li>
	</ol>
</p><p>	
	Ces règles sont très simples et pourtant elles donnent lieu à une évolution qui peut-être très complexe dépendant de la configuration de départ.	
</p>	
	<div>
	<pre><code>
	rem John H. Conway's game of life
	rem simulation automate cellulaire 2D
	dim <a name="cursor"></a>cursor#(24)=(
		$00,$70,$00,
		$00,$70,$00,
		$00,$70,$00,
		$77,$77,$70,
		$00,$70,$00,
		$00,$70,$00,
		$00,$70,$00,
		$00,$00,$00)

	const width=38 ' dimension horizontale de grille
	const height=18 ' dimension verticale de la grille
	const cell=127  ' caractère utilisé pour représenter les cellules
	const empty=32  ' caractère position grille vide
	const k_up=141    ' valeur touche flèche vers le haut
	const k_down=142  ' valeur touche flèche vers le bas
	const k_left=143  ' valeur touche flèche vers la gauche
	const k_right=144 ' valeur touche flèche vers la droite
	const odd=684     ' déplacement grille génération impaire
	dim g#(1368)  'grille univers
	gen=0  'compteur de génération
	src=0  ' déplacement grille source
	des=odd 'déplacement grille destination

    ' sous-routine d'effacement de la grille
	sub clear_grid()
	local i
	  for i=1 to ubound(g#)
		g#(i)=empty
	  next i
	end sub

    ' sous-routine d'affichage de la grille
	sub display_grid()
	local x,y
	 for x=1 to 38
	  for y=1 to 18
	   locate(y,x)
	   putc g#((y-1)*width+x+src)
	  next y
	 next x
	 locate(20,0)
	 print gen ;
	end sub 

    ' initialisation de la grille
    ' avec le modèle de départ.
	sub set_grid()
	local k,x,y
	 x=width/2+1
	 y=height/2+1
	 cls
	 locate(21,0)
	 ? "&lt;SPACE&gt;,&lt;C&gt;,&lt;ENTER&gt;";
	 gen=0
	 src=0
	 des=odd
	 k=0 
	 clear_grid()
	 while k&lt;&gt;13
	  locate(0,0)
	  ? "x:",x," y:",y,"    ";
	  locate(y,x)
	  putc g#((y-1)*width+x)
	  void=sprite(x*6,y*8,6,8,@cursor#)
	  while not k : k= key() : wend
	  void=sprite(x*6,y*8,6,8,@cursor#)
	  select case k
	  case k_up
		if y&gt;1 then y=y-1 end if
	  case k_down
		if y&lt;height then y=y+1 end if
	  case k_left
		if x&gt;1 then x=x-1 end if
	  case k_right
		if x&lt;38 then x=x+1 end if
	  case 32
		g#(width*(y-1)+x)=empty
	  case 67,99
		g#((y-1)*width+x)=cell
	  end select
	  if k&lt;&gt;13 then k=0 end if
	 wend
	 cls
	 ? "&lt;ESC&gt; quit, 'r' new grid";
	end sub

    ' compte le voisinage d'une cellule
	func countn(x,y)
	local n,x0,y0,ofs
	 n=0
	 for x0=max(x-1,1) to min(38,x+1)
	  for y0=max(y-1,1) to min(18,y+1)
	  if x0&lt;&gt;x or y0&lt;&gt;y then
	   ofs=(y0-1)*width+x0+src
	   if g#(ofs)=cell then
		n=n+1
	   end if
	  end if
	  next y0
	 next x0
	 return n 
	end func

    ' calcule les valeurs de la prochaine
    ' génération.
	sub next_gen()
	local n,x,y,ofs
	  for x=1 to 38
	   for y=1 to 18
		n=countn(x,y)
		ofs=(y-1)*width+x
		select case n
		case 2
		 g#(ofs+des)=g#(ofs+src)
		case 3
		 g#(ofs+des)=cell
		case else ' 0,1,4,5,6,7,8
		 g#(ofs+des)=empty
		end select
	   next y
	  next x
	  gen=gen+1
	  src=odd-src
	  des=odd-des
	end sub

    ' boucle principal
    ' du programme
	set_grid()
	r=1
	while r
	  display_grid()
	  next_gen()        
	  select case key()
	  case 27
	   r=0
	  case \r,\R
	   set_grid()
	  end select
	wend
	cls
</code></pre>
<a href="#top">début</a>
</div>
<h4><a name="spred"></a>spred.bas</h4>
<p>
  <b>spred.bas</b>, <i>(sprite editor)</i> est un éditeur de figurine pour les jeux vidéo. On peut définir des sprites directement
  en BASIC comme montré dans l'example précédent avec le <a href="#cursor">cursor</a> mais ce n'est pas très commode. Cet éditeur
  simple permet de les créer et de les sauvegarder sous forme de fichier binaire.
</p>
<p>
 Au démarrage le programme demande le nom du fichier sous lequel le sprite doit-être sauvegarder ou le nom d'un fichier existant
 qui peut-être chargé pour modification. Ensuite les dimensions du sprite sont demandées. <b>width</b> est la largeur en pixels et
 <b>height</b> la hauteur. La grandeur maximale est de <b>32x32 pixels</b>. Une fois ces informations saisies un rectangle apparaît au centre de l'écran avec un <b>x</b> qui représente
 le curseur. Ce rectangle est la zone d'édition zoommée 4X. En haut à gauche apparait les coordonnées du curseur et sous les coordonnées apparaît
 la représentation taille réelle du sprite.<br>
  Les commandes sont entièrement au clavier.
</p>
 <ul>
 <li><b>&lt;L&gt;</b>oad est utilisé pour charger un sprite existant pour modification. Après le chargement un message
 apparaît en bas à gauche de l'écran indiquant que le sprite a été chargé ainsi que ses dimensions. Le sprite est affiché dans
 la grille d'édition. Si le fichier est vide ou n'existe pas le message affiché est <b>Nothing loaded</b>.</li>
 <li><b>&lt;S&gt;</b>ave sauvegarde le sprite dans le fichier nommé en entrée de programme.</li>
 <li><b>Les flèches de direction</b> servent à déplacer le curseur à l'intérieur de la zone d'édition.</li>
 <li><b>&lt;0&gt;-&lt;F&gt;</b> détermine la couleur du pixel. Cette couleur sera utlisée lors de l'enfoncement de la touche <b>ESPACE</b>.
 Ces touches correspondent aux valeurs hexadécimales de 0 à 15 soit les 16 tons de gris.</li>
 <li><b>&lt;ESPACE&gt;</b> applique la couleur sélectionnée à la position courante du curseur.</li>
 <li><b>&lt;ESC&gt;</b> Sortie du programme.</li>
 </ul>
 <p>
 Il s'agit donc d'un programme très simple. On ne peut éditer qu'un seul sprite par session. Cette limitation est du au fait 
 que ce BASIC considère les chaînes de caractères comme des constantes donc la valeur de <i>name$</i> ne peut-être modifiée
 une fois initialisée par la commande <b>INPUT</b> en début de programme. Pour éditer un autre sprite il faut sortir du programme
 et le relancer avec la commande <b>run spred.bas</b>.  Cette limitation peut-être contournée, je vous laisse ce problème à titre
 d'exercice pratique.
</p>
<div>
<pre><code>
	REM editeur de sprite

	' nom, largeur, hauteur, couleur pixel
	dim name$, w, h, c=0
	' tableau contenant le sprite
	dim spr#(512)
	' sprite curseur
	dim c#(8)=($f0,$0f,   
		$0f,$f0,
		$0f,$f0,
		$f0,$0f)
	' x offset, y offset, x, y
	dim xo,yo,x,y
	const psize=4  'dimension pixel zoomé
	const xres=240  'résolution écran horizontale
	const yres=170  ' résolution écran verticale
	cls
	' saisie des paramètres
	input "sprite name", name$
	input "sprite width", w
	input "sprite height", h

    'dessine le rectangle d'édition
	sub draw_bounds()
	 cls
	 xo=(xres-psize*w)/2
	 yo=(yres-psize*h)/2
	 rect(xo-1,yo-1,psize*w+2,psize*h+2,7)
	 x=w/2
	 y=h/2
	end sub

    'affiche les coordonnées {x,y} du curseur
	sub prtxy()
	  locate(0,0)
	  print "x:",x," y:",y ;
	end sub

    'sauvegarde du sprite 
    'dans un fichier binaire
	sub save_sprite()
	  srwrite(0,@w,2)
	  srwrite(2,@h,2)
	  srwrite(4,@spr#,w*h/2)
	  srsave name$,w*h/2+4
	  locate(19,0)
	  ? name$ ,"saved"
	  ? w,"x",h,"pixels";
	end sub

    'dessine le sprite
    'dans le rectangle d'édition
	sub fill_canevas()
	local i,x,y,c
	  for x=0 to w-1
	   for y=0 to h-1
		i=(y*w+x)/2+1
		if btest(x,0) then
		  c=spr#(i)%16
		else
		  c=spr#(i)/16
		end if
		box(xo+x*psize,yo+y*psize,psize,
		psize,c)
		setpixel(10+x,10+y,c)
	   next y
	  next x
	end sub

    'charge un fichier binaire
    'sprite
	sub load_sprite()
	local size
	 size=srload name$
	 if size then
	   srread(0,@w,2)
	   srread(2,@h,2)
	   srread(4,@spr#,size-4)
	   draw_bounds()
	   fill_canevas()
	   locate(19,0)
	   ? name$, "loaded"
	   ? "width",w,"height",h ;
	 else
	   locate(19,0)
	   ? "load failed";
	 end if
	end sub

    'assigne la couleur du pixel
    '{x,y} dans le tableau
	sub let_pixel(x,y,c)
	local idx
	  idx=(y*w+x)/2+1
	  if btest(x,0) then 'impair
	   spr#(idx)=spr#(idx)/16*16+c
	  else ' pair
	   spr#(idx)=spr#(idx)%16+c*16
	  end if
	end sub


	draw_bounds()

    ' boucle principale du programme
	while 1
	 prtxy()
	 sprite(xo+x*psize,yo+y*psize,psize,
	 psize,@c#)
	 pause(20)
	 sprite(xo+x*psize,yo+y*psize,psize,
	 psize,@c#)
	 k=key()
	 if k&gt;=\a then k=k-32 end if
	 select case k
	 ' sélection couleur 0-9
	 case \0,\1,\2,\3,\4,\5,\6,\7,\8,\9
	  c=k-\0
	  ' sélection couleur A-F
	 case \A,\B,\C,\D,\E,\F
	  c=k-\A+10
	 case 32 ' ESPACE  = colore le pixel
	  box(xo+x*psize,yo+y*psize,psize,
	  psize,c)
	  setpixel(10+x,10+y,c)
	  let_pixel(x,y,c)
	 case 141 ' déplacement vers le haut
	  if y>0 then y=y-1 end if
	 case 142 ' déplacement vers le bas
	  if y&lt;h-1 then y=y+1 end if
	 case 143 ' déplacement vers la gauche
	  if x&gt;0 then x=x-1 end if
	 case 144 ' déplacement vers la droite
	  if x&lt;h-1 then x=x+1 end if
	 case 27 ' ESC = quit
	  cls
	  bye
	 case \S  ' sauvegarde sprite
	  save_sprite()
	 case \L  ' charge sprite
	  load_sprite()
	 end select
	wend

</code></pre>
<a href="#top">début</a>
</div>
<hr width="50%" align="center">
<p>
	<ul>
		<li><a href="#top">début</a></li>
		<li><a href="./pv16sog.html">ordinateur PV16SOG</a></li>
		<li><a href="./shell.html">shell du PV16SOG</a></li>
		<li><a href="./editor.html">Éditeur du PV16SOG</a></li>
        <li><a href="./BASIC.html">BASIC du PV16SOG</a></li>
        <li><a href="./stackvm.html">machine virtuelle du PV16SOG</a></li>
	</ul>
</p>

</body>
</html>
